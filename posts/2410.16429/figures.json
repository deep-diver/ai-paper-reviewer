[{"figure_path": "2410.16429/figures/figures_5_0.png", "caption": "Fig. 1: A proof tree for Expression (1)", "description": "The figure shows a proof tree for the expression  \u2200(p:Prop), \u2200(q:Prop), \u2200(h:p\u2228q), q\u2228p, which represents the commutativity of the logical OR operation. The tree is an and-or tree, illustrating the steps involved in proving the theorem using tactics in the Lean 4 proof assistant.  The tree's nodes represent goals (or subgoals) and the edges represent tactics applied to transform goals. The figure visualizes how a series of tactics (intro p, intro q, intro h, cases h, apply V.inr, exact hp, apply V.inl, exact hq) progressively reduces the initial goal into smaller subgoals until they are finally solved, thereby constructing a complete proof of the theorem.", "section": "2.2 Tree Search"}, {"figure_path": "2410.16429/figures/figures_7_0.png", "caption": "Fig. 2: System architecture of Pantograph. A solid arrow indicates that the component at the arrow source calls functions in the component that is the arrow's target. A human operator interacts with Lean 4's kernel via the IDE, but a machine learning agent can interact via one of Pantograph's interfaces.", "description": "The figure presents a diagram illustrating the system architecture of Pantograph.  It shows two primary user interaction methods: a human operator interacting through an IDE, and a machine learning agent interacting through Pantograph's interfaces (REPL). Both interaction methods ultimately communicate with the Lean Kernel through either the Lean LSP or Pantograph. The Lean Kernel, in turn, reads from the Lean Project, which represents the codebase. Solid arrows indicate the direction of function calls between components.", "section": "4 Architecture and Features"}, {"figure_path": "2410.16429/figures/figures_7_1.png", "caption": "Fig. 3: Call hierarchy in Pantograph during the execution of a normal tactic. The text on the right indicates the Lean 4 monad each function runs in.", "description": "The figure presents a call hierarchy diagram illustrating the internal function calls within Pantograph during the execution of a standard tactic. The diagram shows a sequence of nested function calls, starting from the main function (in IO monad) and proceeding through loop (CoreM monad), Pantograph.execute (CoreM monad), Pantograph.GoalState.tryTactic (TermElabM monad), and finally Lean.Elab.Tactic.evalTactic (TacticM monad).  Each function call is represented by a box, with the corresponding Lean 4 monad indicated to the right.  The diagram visually depicts the layered structure and monadic context of the tactic execution process within Pantograph.", "section": "4 Architecture and Features"}, {"figure_path": "2410.16429/figures/figures_10_0.png", "caption": "Fig. 4: 2 becomes dormant after a tactic is applied to 1. It must be brought back into scope with goal.continue before the proof can finish. The ellipses (...) are plalceholders for some combination of tactics which eventually solves the descendant of (1", "description": "This figure illustrates the concept of dormant goals in Pantograph's tree search. It shows a proof state with two goals, represented as circles, labeled 1 and 2. Applying the 'cases h' tactic to the initial goal results in a new proof state with goals 1 and 2. Goal 2 becomes dormant, indicated by a dashed green line, because it is not actively being worked on. To continue the proof, the user must bring goal 2 back using the 'continue' command, allowing the user to resume working with goal 2.", "section": "4.2 Tree Search"}, {"figure_path": "2410.16429/figures/figures_11_0.png", "caption": "Fig. 5: In this diagram, rectangular boxes are proof states, and circles are goals. Each proof state has 0 or more goals. A state with no goals is considered solved. If all descendant goals of a state become solved, the state itself becomes solved.", "description": "The figure illustrates the process of metavariable coupling using a simple example.  It starts with a single goal, 2 \u2264 5, which, upon application of the tactic `apply Nat.le_trans`, branches into three coupled subgoals: 2 \u2264 \u2461, \u2461 \u2264 5, and  2:N.  The coupled subgoal \u2461 represents a metavariable shared among the subgoals. Applying the tactic `exact 3` to the subgoal involving the metavariable solves that subgoal, leaving the other two goals dormant.  The `continue` command reactivates these dormant goals, which are then solved individually using the `decide` tactic, completing the proof.", "section": "4.3 Metavariable Coupling"}]