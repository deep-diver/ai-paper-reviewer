[{"figure_path": "2410.16429/figures/figures_5_0.png", "caption": "Fig. 1: A proof tree for Expression (1)", "description": "The figure shows a proof tree for the expression representing the commutativity of logical OR, illustrating the structure generated by applying tactics in a proof assistant.", "section": "2 Background"}, {"figure_path": "2410.16429/figures/figures_7_0.png", "caption": "Fig. 2: System architecture of Pantograph. A solid arrow indicates that the component at the arrow source calls functions in the component that is the arrow's target. A human operator interacts with Lean 4's kernel via the IDE, but a machine learning agent can interact via one of Pantograph's interfaces.", "description": "The figure illustrates the system architecture of Pantograph, showing how machine learning agents and human operators interact with the Lean 4 kernel via different interfaces.", "section": "4 Architecture and Features"}, {"figure_path": "2410.16429/figures/figures_7_1.png", "caption": "Fig. 3: Call hierarchy in Pantograph during the execution of a normal tactic. The text on the right indicates the Lean 4 monad each function runs in.", "description": "The figure shows the call hierarchy of functions in Pantograph during the execution of a tactic, indicating the Lean 4 monad each function runs in.", "section": "4 Architecture and Features"}, {"figure_path": "2410.16429/figures/figures_10_0.png", "caption": "Fig. 4: 2 becomes dormant after a tactic is applied to 1. It must be brought back into scope with goal.continue before the proof can finish. The ellipses (...) are plalceholders for some combination of tactics which eventually solves the descendant of 1", "description": "The figure illustrates how a goal becomes dormant in Pantograph when using manual tree search and how to bring it back into scope using the goal.continue command.", "section": "4.2 Tree Search"}, {"figure_path": "2410.16429/figures/figures_11_0.png", "caption": "Fig. 5: In this diagram, rectangular boxes are proof states, and circles are goals. Each proof state has 0 or more goals. A state with no goals is considered solved. If all descendant goals of a state become solved, the state itself becomes solved.", "description": "The figure illustrates the workflow of metavariable coupling in Pantograph, showing how goals are solved sequentially and how dormant goals are handled.", "section": "4.3 Metavariable Coupling"}]