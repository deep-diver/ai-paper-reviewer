[{"figure_path": "2410.15748/figures/figures_3_0.png", "caption": "Figure 1: The overview of our synthesis pipeline. At the theorem level, we find invocable theorems that can be used to rewrite or apply to the assumptions or assertion of the candidate statement, such as the iff and implication rules about the Coprime. Then, we construct the new statements by replacing the specific component with its equivalent form or antecedent. At the proof tree level, our method merges two existing proof trees.", "description": "This figure illustrates the Alchemy framework's data synthesis pipeline, showing how it constructs new theorems through symbolic manipulation at the theorem level and proof tree merging.", "section": "3 METHOD"}, {"figure_path": "2410.15748/figures/figures_8_0.png", "caption": "Figure 1: The overview of our synthesis pipeline. At the theorem level, we find invocable theorems that can be used to rewrite or apply to the assumptions or assertion of the candidate statement, such as the iff and implication rules about the Coprime. Then, we construct the new statements by replacing the specific component with its equivalent form or antecedent. At the proof tree level, our method merges two existing proof trees.", "description": "The figure illustrates the Alchemy framework's data synthesis pipeline, showing how it constructs new theorems by symbolically manipulating existing ones at both the theorem and proof tree levels.", "section": "3 METHOD"}, {"figure_path": "2410.15748/figures/figures_19_0.png", "caption": "Figure 1: The overview of our synthesis pipeline. At the theorem level, we find invocable theorems that can be used to rewrite or apply to the assumptions or assertion of the candidate statement, such as the iff and implication rules about the Coprime. Then, we construct the new statements by replacing the specific component with its equivalent form or antecedent. At the proof tree level, our method merges two existing proof trees.", "description": "This figure illustrates the Alchemy data synthesis pipeline, showing how it constructs new theorems by symbolically mutating existing ones at both the theorem and proof tree levels.", "section": "3 METHOD"}, {"figure_path": "2410.15748/figures/figures_23_0.png", "caption": "Figure 6: The distribution of the number of variants (only 99% of the data are visualized).", "description": "The figure shows the distribution of the number of variants generated for each tactic (rw and apply).", "section": "D Deeper Analysis of Synthetic Dataset"}, {"figure_path": "2410.15748/figures/figures_24_0.png", "caption": "Figure 1: The overview of our synthesis pipeline. At the theorem level, we find invocable theorems that can be used to rewrite or apply to the assumptions or assertion of the candidate statement, such as the iff and implication rules about the Coprime. Then, we construct the new statements by replacing the specific component with its equivalent form or antecedent. At the proof tree level, our method merges two existing proof trees.", "description": "The figure illustrates the synthesis pipeline of generating new theorems by symbolically mutating existing ones and merging their proof trees.", "section": "3 METHOD"}, {"figure_path": "2410.15748/figures/figures_27_0.png", "caption": "Figure 1: The overview of our synthesis pipeline. At the theorem level, we find invocable theorems that can be used to rewrite or apply to the assumptions or assertion of the candidate statement, such as the iff and implication rules about the Coprime. Then, we construct the new statements by replacing the specific component with its equivalent form or antecedent. At the proof tree level, our method merges two existing proof trees.", "description": "The figure illustrates the data synthesis pipeline, showing how invocable theorems are identified and used to mutate candidate theorems at both the theorem and proof tree levels.", "section": "3 METHOD"}, {"figure_path": "2410.15748/figures/figures_29_0.png", "caption": "Figure 1: The overview of our synthesis pipeline. At the theorem level, we find invocable theorems that can be used to rewrite or apply to the assumptions or assertion of the candidate statement, such as the iff and implication rules about the Coprime. Then, we construct the new statements by replacing the specific component with its equivalent form or antecedent. At the proof tree level, our method merges two existing proof trees.", "description": "The figure illustrates the data synthesis pipeline, showing how invocable theorems are identified and used to mutate candidate theorems at both the theorem and proof tree levels.", "section": "3 METHOD"}, {"figure_path": "2410.15748/figures/figures_31_0.png", "caption": "Figure 1: The overview of our synthesis pipeline. At the theorem level, we find invocable theorems that can be used to rewrite or apply to the assumptions or assertion of the candidate statement, such as the iff and implication rules about the Coprime. Then, we construct the new statements by replacing the specific component with its equivalent form or antecedent. At the proof tree level, our method merges two existing proof trees.", "description": "The figure illustrates the data synthesis pipeline, showing how new theorems are constructed by symbolically mutating existing theorems and merging their proof trees.", "section": "3 METHOD"}]